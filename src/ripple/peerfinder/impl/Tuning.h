
//此源码被清华学神尹成大魔王专业翻译分析并修改
//尹成QQ77025077
//尹成微信18510341407
//尹成所在QQ群721929980
//尹成邮箱 yinc13@mails.tsinghua.edu.cn
//尹成毕业于清华大学,微软区块链领域全球最有价值专家
//https://mvp.microsoft.com/zh-cn/PublicProfile/4033620
//————————————————————————————————————————————————————————————————————————————————————————————————————————————————
/*
    此文件是Rippled的一部分：https://github.com/ripple/rippled
    版权所有（c）2012，2013 Ripple Labs Inc.

    使用、复制、修改和/或分发本软件的权限
    特此授予免费或不收费的目的，前提是
    版权声明和本许可声明出现在所有副本中。

    本软件按“原样”提供，作者不作任何保证。
    关于本软件，包括
    适销性和适用性。在任何情况下，作者都不对
    任何特殊、直接、间接或后果性损害或任何损害
    因使用、数据或利润损失而导致的任何情况，无论是在
    合同行为、疏忽或其他侵权行为
    或与本软件的使用或性能有关。
**/

//==============================================================

#ifndef RIPPLE_PEERFINDER_TUNING_H_INCLUDED
#define RIPPLE_PEERFINDER_TUNING_H_INCLUDED

#include <array>

namespace ripple {
namespace PeerFinder {

/*启发式调谐常数。*/
/*@ {*/
namespace Tuning {

enum
{
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————
//
//自动连接策略
//
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————

    /*在进行批量连接尝试之间等待的时间*/
    secondsPerConnect = 10

    /*同时连接尝试的最大次数。*/
    ,maxConnectAttempts = 20

    /*出站对等机插槽总数的百分比。
        出站对等机的数量将是
        MinOutCount和Outpercent*配置：：MaxPeers
        圆形的
    **/

    ,outPercent = 15

    /*传出连接数的硬最小值。
        这是在逻辑之外强制执行的，因此单元测试
        可以使用它想要的任何设置。
    **/

    ,minOutCount = 10

    /*config:：maxpeers的默认值。*/
    ,defaultMaxPeers = 21

    /*我们将接受一个连接的最大重定向次数。
        重定向仅限于安全目的，以防止
        地址缓存以防被淹没。
    **/

    ,maxRedirects = 30
};

//————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//
//固定的
//
//————————————————————————————————————————————————————————————————————————————————————————————————————————————————

static std::array <int, 10> const connectionBackoff
    {{ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 }};

//————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//
//引导缓存
//
//————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum
{
//缓存项的阈值，超过该阈值时进行修剪。
    bootcacheSize = 1000

//修剪缓存时所修剪地址的百分比。
    ,bootcachePrunePercent = 10
};

//数据库更新之间的冷却等待
//理想情况下，这应该比一个完整的
//对等机向我们发送一组地址，然后断开连接。
//
static std::chrono::seconds const bootcacheCooldownTime (60);

//————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//
//利瓦切奇
//
//————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum
{
//删除跃点大于此数字的传入邮件
    maxHops = 6

//每个mtendpoints中要发送多少个端点
    ,numberOfEndpoints = 2 * maxHops

//我们将在mtendpoints中接受的最大端点
    ,numberOfEndpointsMax = 20

//默认情况下我们需要的对等数，除非
//显式值在配置文件中设置。
    ,defaultMaxPeerCount = 21

    /*重定向时提供的地址数。*/
    ,redirectEndpointCount = 10
};

//每对等端发送或接受mtendpoints消息的频率
static std::chrono::seconds const secondsPerMessage (5);

//端点将在缓存中停留多长时间
//这应该是广播频率的小倍数
static std::chrono::seconds const liveCacheSecondsToLive (30);

//
//
//

//在再次尝试传出地址之前要等待多长时间。
//注意，为了进行比较，我们忽略了端口。
static std::chrono::seconds const recentAttemptDuration (60);

}
/*@ }*/

}
}

#endif
